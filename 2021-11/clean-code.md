## Clean Code

<b>Back to [Homepage](../index.md)</b>

## 序

那班求索者多年来并肩奋斗，不但是为求一己之进步，更将他们的知识通过和你手上正在做的事一般的工作贡献给这个行业。

## 代码猴子与童子军军规

宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。

写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的‘整洁感’。这种‘代码感’就是关键所在……

## 前言

穷尽应知之事，并且要对其了如指掌，通过刻苦实践掌握它。

本书要让你用功，而且是非常用功。如何用功？阅读代码——大量代码。而且你要去琢磨某段代码好在什么地方、坏在什么地方。

## 第1章 整洁代码

我们永远抛不掉代码，因为代码呈现了需求的细节。

归置良好的需求就像代码一样正式，也能作为代码的可执行测试来使用。

Later equals never.

混乱的代码是祸首。

做得快的唯一方法是保持代码整洁。

代码逻辑应当直截了当，叫缺陷难以隐藏。

尽量减少依赖关系，使之便于维护。

依据某种分层战略完善错误处理代码。

整洁的代码读起来令人愉悦。

完善错误处理代码。

整洁的代码只做好一件事。

整洁的代码从不隐藏设计者的意图。

整洁的代码总是看起来像是某位特别在意它的人写的。

没有重复代码。

体现系统中的全部设计理念。

包括尽量少的实体，比如类、方法、函数等。

有意义的命名是体现表达力的一种方式。

消除重复代码，提高表达力，提早构建简单抽象。

不要重复代码，只做一件事，表达力，小规模抽象。

每个例程都让你感到深合己意。

那代码就是深合你意。它明确、简单、有力。

整洁的程序好到你根本不会注意到它。

读与写花费时间的比例超过10:1。

"让营地比你来时更干净。"

艺术书并不保证你读过之后才能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。

若我们受人所制，亲爱的勃鲁托斯，那错也在我们身上，不能怪罪命运。

## 第2章 有意义的命名

名副其实。

如果名称需要注释来补充，那就不算是名副其实。

选择体现本意的名称能让人梗荣立理解和修改代码。

问题不在于代码的简洁度，而是在于代码的模糊度：即上下文在代码中未被明确体现的程度。

只要简单改一下名称，就能轻易知道发生了什么。

以同样的方式拼写出同样的概念才是信息。瓶邪前后不一致就是误导。

如果名称必须相异，那其意思也应该不同才对。

废话是另一种没意义的区分。废话都是冗余。

要区分名称，就要以读者能鉴别之处的方式来区分。

使用读得出来的名称，如果名称读不出来，讨论的时候就会像个傻鸟。

单字母名称仅用于短方法中的本地变量。名称长短应与其作用于大小相对应。

长名称胜于短名称，搜得到的名称胜于用自造代码写就的名称。

把类型或作用于编进名称里面，徒然增加了解码的负担。

应当把类和函数做得足够小，消除对成员前缀的需要。

聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。

类名和对象名应该是名词或名词短语，类名不应当是动词。

方法名应当是动词或动词短语，属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。

重载构造器时，使用描述了参数的静态工厂方法名。可以考虑将相应的构造器设置为private，强制使用这种命名手段。

    Complex.FromRealNumber(23.0) 通常好于 new Complex(23.0)

宁可明确，毋为好玩。言到意到，意到言到。

给每个抽象概念选一个词，并且一以贯之。

    例如，使用fetch、retrieve和get来给多个类中的同种方法命名。

函数名称应当独一无二，而且要保持一致，这样才能不借助多余的浏览就找到正确的方法。

避免将同一单词用于不同目的。遵循"一词一意"。

代码作者应尽力写出易于理解的代码。

使用解决方案领域名称。

使用源自所涉问题领域的名称。

    优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念。

添加有意义的语境。

只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。

    精确是命名的要点。

取好名字最难的地方在于需要良好的描述技巧和共有文化背景。

## 第3章 函数

函数的第一规则是要短小。函数的缩进层级不该多于一层或两层。

函数只做一件事。只做一件事的函数无法再被切分为多个区段。

    编写函数是为了把大一些的概念拆分为另一抽象层上的一系列步骤。
    换言之，函数应该只在紧邻的两个抽象层次上拆解，而不应该跨越多个抽象层次。

每个函数一个抽象层级。

自顶向下阅读代码：向下规则。

Switch语句天生要做N件事，写出短小的switch语句很难。

    switch语句尽量只出现于工厂方法中用于创建多态对象，而且隐藏在某个继承关系中，在系统的其他部分看不到。

长而具有描述性的名称，要比短而令人费解的名称好。

函数参数越少越好。

    参数与函数名处在不同的抽象层级，它要求你了解目前并不特别重要的细节。

单参数函数可能是操作该参数，将其转换再输出；也有可能是将参数视为事件（event），有输入而无输出，此时函数使用该参数修改系统状态。

不要使用标识参数，标识参数丑陋不堪，它是在宣布本函数不止做一件事。

如果函数需要三个或以上的参数，就说明其中一些参数应该封装为类了。

    一组参数被统统传递，往往就是该有自己名称的某个概念的一部分。

给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。

    函数和参数应当形成一种非常良好的动词/名词对形式。

无副作用：函数承诺只做一件事。

    应避免使用输出参数，如果必须要修改某种状态，就修改所属对象的对象。

分隔指令与询问

    函数要么做什么事，要么回答什么事，但二者不可兼得。

使用异常替代返回错误码：错误处理代码就能从主路径中分离出来，得到简化。

抽离Try/Catch代码块，另外形成函数，分离Control和具体Logic。

函数应该只做一件事，错误处理就是一件事，因此，处理错误的函数不该做其他事。

使用异常代替错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。

Don't repeat yourself.

    重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。

> 每个系统都是使用某种领域特定语言搭建，而这种语言是程序员设计来描述那个系统的。
> 
> 函数是语言的动词，类是名词。
> 
> 编程艺术是且一直就是语言设计的艺术。
> 大师级程序员把系统当做故事来讲，而不是当做程序来写。
> 
> 真正的目标在于讲述系统的故事，而你编写的函数必须干净利落地拼装到一起，形成一种精确而清晰的语言，帮助你讲故事。

## 第4章 注释

若编程语言足够有表达力，或者我们擅长用这些语言来表达意图，就不那么需要注释——也许根本不需要。

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

代码在变动，在演化，程序员不能坚持维护注释，注释并不总是随之变动。

不准确的注释要比没注释坏得多。

只有代码能忠实地告诉你它做的事。那是唯一真正准确的信息来源。

注释不能美化糟糕的代码。尽量用代码来阐释意图而不是注释。

唯一真正好的注释是你想办法不去写的注释。

有时，注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式，也会是有用的。

有时，用于警告其他程序员会出现某种后果的注释也是有用的。

注释可以用来放大某种看来不合理之物的重要性。

没有什么比被良好描述的公共API更有用和令人满意的了。

怀注释都是糟糕的代码的支撑或借口，或者对错误决策的修正，基本上等于程序员自说自话。

如果你决定写注释，就要花必要的时间确保写出最好的注释。

程序员的挫败感可以由改进代码结构而消除。

用整理代码的决心来代替创造废话的冲动吧。你会发现自己成为更优秀、更快乐的程序员。

能用函数或变量时就别用注释。

假如你一定要写注释，请确保它描述了离它最近的代码。

别在注释中添加过多或无关的细节描述。

注释及其描述的代码之间的联系应该显而易见。

为只做一件事的短函数选个好名字，通常要比写函数头注释要好。

## 第5章 格式

代码格式很重要。

    代码格式关乎沟通，而沟通是专业开发者的头等大事。

短文件通常比长文件易于理解。

    有可能用大多数为200行，最长500行的单个文件构造出色的系统。

源文件也要像报纸文章那样，名称应当简单且一目了然。

每个空白行都是一条线索，标识出新的独立概念。

空白行隔开了概念，靠近的代码行则暗示了它们之间的紧密关系。紧密相关的代码应该互相靠近。

变量声明应尽可能靠近其使用位置。

相关性越强，彼此之间的距离就该越短。

应该尽力保持代码行短小。

源文件是一种继承结构，其中的信息设计整个文件、文件中每个类、类中的方法、方法中的代码块，也涉及代码块中的代码块。

要让这种范围式继承结构可见，我们依源代码在继承结构中的位置对源代码行做缩进处理。

程序员相当依赖这种缩进模式。

好的软件系统是由一系列读起来不错的代码文件组成的。

## 第6章 对象和数据结构

隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象。

要以最好的方式呈现某个对象包含的数据，需要做严肃的思考。

对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。它们是对立的。

过程式代码（使用数据结构的代码），便于在不改动既有数据结构的前提下添加新函数。

    过程式代码难以添加新数据结构，因为必须修改所有函数。

面向对象代码便于在不改动既有函数的前提下添加新类。

    面向对象代码难以添加新函数，因为必须修改所有类。

> 对于面向对象比较难的事，对于过程式代码却较容易，反之亦然！

模块不应了解它所操作对象的内部情形。

对象隐藏数据，暴露操作，这意味着对象不应通过存取器暴露其内部结构。

方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友说话，不与陌生人谈话。

使用公共访问器把私有变量公开化，会诱导外部函数以过程式程序使用数据结构的方式使用这些变量。

如果ctx是个变量，就应该要求它做点什么，不该要求它给出内部情形。

> 对象暴露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。

    不过貌似Rust的trait可以在不破坏既有继承/接口实现的前提下，无侵入式的为一个已有的类增加一个新的接口实现

> 数据结构暴露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。

我们有时会希望能够灵活地添加新数据类型，所以更喜欢在这部分使用对象。

另外一些时候，我们希望能灵活地添加新行为，这时我们更喜欢使用数据类型和过程。

## 第7章 错误处理

错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。

使用异常而非返回码。

    他们搞乱了调用者代码。调用者必须在调用之后即刻检查错误，而这个步骤很容易被遗忘。

在某种意义上，try代码块就像是事务。catch代码块将程序维持在一种持续状态。

可控异常的代价就是违反开放/闭合原则。

    你得在catch语句和抛出异常处之间的每个方法签名中声明该异常。
    这意味着对软件中较低层级的修改，都将波及较高层级的签名。

可控异常有时也会有用：在那些关键代码库的地方，你必须捕获异常。

你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。

    应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。

当我们在应用程序中定义异常类时，最重要的考虑应该是它们如何被捕获。

将第三方API打包是个良好的实践手段。

    当你打包一个第三方API，你就降低了对它的依赖。
    打包的好处还在于你不必绑死在某个特定厂商的API设计上。

别返回null值。

    返回null值，基本上是在给自己增加工作量，也是在给调用者添乱。
    只要有一处没检查null值，应用程序就会失控。

别传递nul值。

    除非API要求你向它传递null值，否则就要尽可能避免传递null值。
    在大多数编程语言中，没有良好的方法能对付由调用者意外传入的null值。
    恰当的做法就是禁止传入null值。

> 整洁代码是可读的，但也要强固。  
> 可读与强固并不冲突。  
> 如果将错误处理隔离看待，独立于主逻辑之外，就能写出强固而整洁的代码。  
> 单独处理错误，极大地提升了代码的可维护性。  

## 第8章

我们很少控制系统中的全部软件。

在接口提供者和使用者之间，存在与生俱来的张力。

    第三方程序包和框架提供者追求普适性，而使用者则想要集中满足特定需求的接口。
    这种张力会导致系统边界上出现问题。

边界上的接口是隐藏的，它能随来自应用程序其他部分的极小的影响而变动。

我们简易不要将Map（或在边界上的其他接口）在系统中传递。避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。

我们没有测试第三方代码的职责，但为要使用的第三方代码编写测试，可能最符合我们的利益。

学习第三方代码很难。整合第三方代码也很难。同时做着两件事难上加难。

不要再生产代码中试验新东西，而是编写测试来遍览和理解第三方代码。这叫做学习性测试（leaning tests）。

    我们基本上是在通过核对试验来检测自己对那个API的理解程度。
    测试聚焦于我们想从API得到的东西。

学习性测试毫无成本。
    
    无论如何我们都得学习要使用的API，而编写测试则是获得这些知识的容易而不会影响其他工作的途径。
    学习性测试是一种精确试验，帮助我们增进对API的理解。

当第三方程序包发布了新版本，我们可以运行学习性测试，看看程序包的行为有没有改变。

学习性测试确保第三方程序包按照我们想要的方式工作。

总要有一系列与生产代码中调用方式一致的输出测试来支持整洁的边界。

还有另一种边界，那种将已知和未知分隔开的边界。

    在代码中总有许多地方是我们的知识未及之处，至少目前未知，边界的那边就是未知的。

边界上会发生有趣的事。改动是其中之一。

    有良好的软件设计，无需巨大投入和重写即可进行修改。

边界上的代码需要清晰的分隔和定义了期望的测试。
    
    应该避免我们的代码过多地了解第三方代码中的特定信息。
    依靠你能控制的东西，好过依靠你控制不了的东西。

## 第9章 单元测试

保持测试整洁。

    脏测试等同于没测试——如果不是坏于的话。
    测试是必须随生产代码的演进而修改。

测试代码和生产代码一样重要。它需要被思考、被设计和被照料。

测试带来一切好处。

正是单元测试让你的代码可扩展、可维护、可复用。

测试覆盖率越高，你就越不担心，越有信心。

整洁的测试有三个要素：可读性，可读性和可读性。

    测试可遵循以下模式：构造 - 操作 - 检验。

测试代码应当简单、精悍、足具表达力，但它该和生产代码一样有效。

有些事你大概永远不会在生产环境中做，而在测试环境中做却完全没问题。通常这关乎内存或CPU效率的问题。

单个测试中的断言数量应该最小化。

每个测试函数中只测试一个概念。

整洁的测试还有以下规则：

- Fast: 快速，测试应该够快。
- Independent: 独立，测试应该相互独立。
- Repeatable：可重复，测试应当在任何环境中重复通过。
- Self-Validating：自足验证，测试应该有布尔值输出，无论通过或失败，都不需要通过查看日志文件来确认。
- Timely：及时，测试应及时编写，在生产代码之前编写。

> 或许测试更为重要，因为它保证和增强了生产代码的可扩展性、可维护性和可复用性。
> 如果你坐视测试腐败，那么代码也会跟着腐败。保持测试整洁吧。

## 第10章 类

类应该短小——其权责应足够小。

类的名称应描述其权责。

    命名正式帮助判断类的长度的第一个手段。
    如果无法为某个类命以精确的名称，这个类大概就太长了。
    如果类名中包括含义模糊的词，如Processor或Manager或Super，这种现象往往说明不恰当的权责聚集。

单一权责原则（Single Responsibility Principle）认为，类或模块有且只有一条加以修改的理由。

    类只应有一个权责——只有一条修改的理由。
    鉴别权责（修改的理由）帮助我们在代码中认识到并创建出更好的抽象。

让软件能工作和让软件保持整洁，是两种截然不同的工作。

    一定规模的系统都会包括大量逻辑和复杂性。
    管理这种复杂性的首要目标就是加以组织，以便开发者知道到哪儿能找到东西，并且在某个特定时间只需要理解直接相关的复杂性。
    反之，拥有巨大的、多目的类的系统，总是让我们在目前不需要了解的一大堆东西中艰难跋涉。

系统应该有许多短小的类而不是少量巨大的类组成。

    每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。

类应该只有少量实体变量。

内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。

当类丧失了内聚性，就拆分它！

    将大函数拆分为许多小函数，往往也是将类拆分为多个小类的时机。
    
在整洁的系统中，我们对类加以组织，以降低修改的风险。

    对类的任何修改都有可能破坏类中的其他代码。必须全面重新测试。

一旦打开了类，就应当修正设计方案。

开放-封闭原则（Open Close Priciple）：类应当对扩展开放，对修改封闭。

在理想系统中，我们通过扩展系统而非修改现有代码来添加新特性。

    具体类包含实现细节，而抽象类则只呈现概念。
    我们可以借助接口和抽象类来隔离这些细节带来的影响。

通过降低连接度，我们的类就遵循了另一条类设计原则，依赖倒置原则（Dependency Inversion Principle）。

    DIP认为类应当依赖于抽象而不是依赖于具体细节。

## 第11章 系统

“复杂要人命。它消磨开发者的生命，让产品难以规划、构建和测试。”。

你能自己掌握一切细节吗？大概不行。

城市能运转，还因为它演化出恰当的抽象等级和模块，好让个人和他们所管理的“组件”即便在不了解全局时也能有效地运转。

将系统的构造与使用分开。

    构造与使用是非常不一样的过程。

软件系统将启始过程与启始过程之后的运行时逻辑分离开，每个应用程序都该留意启始过程。

    将关注的方面分离开，是软件技艺中最古老也是最重要的设计技巧。

可以使用抽象工厂模式让应用自行控制何时创建对象，但构造的细节却隔离于使用的客户端代码之外。

有一种强大的机制可以实现分离构造与使用，那就是依赖注入（Dependency Injection, DI），控制反转（Inversion of Control, IOC）在依赖管理中的一种应用手段。

    控制反转将第二权责从对象中拿出来，转移到另一个专注于此的对象中，从而遵循了单一权责原则。

“一开始就做对系统“纯属神话。反之，我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。

    这就是迭代和增量敏捷的精髓所在。
    测试驱动开发、重构以及它们打造出的整洁代码，在代码层面保证了这个过程的实现。

在AOP中，被称为切面（aspect）的模块构造指明了系统中哪些点的行为会以某种一致的方式被修改，从而支持某种特定的场景。这种说明是用某种简洁的声明或编程机制来实现的。

编程工具能自动处理大多数代理模板代码。

使用XML配置文件或Java5 annotation，EJB3很大程度上遵循了Spring通过描述性手段支持横切面的模型。

没必要先做大设计（Big Design Up Front，BDUF）。

    实际上，BDUF甚至是有害的，它阻碍改进，因为心理上会抵制丢弃既成之事，
    也因为架构上的方案选择影响到后续的设计思路。

我们可以从“简单自然”但切分良好的架构开始做软件项目，快速交付可工作的用户故事，随着规模的增长添加更多基础架构。

在没能真正得到使用时，设计得再好的API也等于杀鸡用牛刀。

最佳的系统架构有模块化的切面领域组成，每个切面均用纯Java对象实现。不同的领域之间用最不具有侵害性的切面或类方面工具整合起来。

    模块化和关注切面成就了分散化管理和决策。

最好是授权给最有资格的人。

    延迟决策到最后一刻也是好手段，它让我们能够基于最有可能的信息作出选择。

有了标准，就更容易复用想法和组件、雇佣拥有相关经验的人才、封装好点子，以及将组件连接起来。

领域特定语言（Domain-Specific-Language, DSL）是一种单独的小型脚本语言或以标准语言写就的API，领域专家可以用它编写读起来像是组织严谨的散文一般的代码。

    优秀的DSL填平了领域概念和实现领域概念的代码之间的“壕沟”，就像敏捷实践优化了开发团队和甲方之间的沟通一样。

DSL在有效使用时能提升代码惯用法和设计模式之上的抽象层次。它允许开发者在恰当的抽象层级上直指代码的初衷。

> 系统也应该是整洁的。

> 侵害性架构会湮灭领域逻辑，冲击敏捷能力。

    当领域逻辑收到困扰，质量也就堪忧，因为缺陷更易隐藏，用户故事更难实现。
    当敏捷能力收到损害时，生产力也会降低。

> 在所有的抽象层级上，意图都应该清晰可辨。

    只有在编写POJO并使用类方面的机制来无损地组合其他切面时，这种事情才会发生。

> 无论是设计系统或单独的模块，别忘了使用大概可工作的最简单方案。

## 第12章 迭进

据Kent所述，只要遵循以下规则，设计就能变得“简单”：

- 运行所有测试；
- 不可重复；
- 表达了程序员的意图；
- 尽可能减少类和方法的数量；

        以上规则按其重要程度排列

































