## Clean Code

<b>Back to [Homepage](../index.md)</b>

## 序

那班求索者多年来并肩奋斗，不但是为求一己之进步，更将他们的知识通过和你手上正在做的事一般的工作贡献给这个行业。

## 代码猴子与童子军军规

宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。

写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的‘整洁感’。这种‘代码感’就是关键所在……

## 前言

穷尽应知之事，并且要对其了如指掌，通过刻苦实践掌握它。

本书要让你用功，而且是非常用功。如何用功？阅读代码——大量代码。而且你要去琢磨某段代码好在什么地方、坏在什么地方。

## 第1章 整洁代码

我们永远抛不掉代码，因为代码呈现了需求的细节。

归置良好的需求就像代码一样正式，也能作为代码的可执行测试来使用。

Later equals never.

混乱的代码是祸首。

做得快的唯一方法是保持代码整洁。

代码逻辑应当直截了当，叫缺陷难以隐藏。

尽量减少依赖关系，使之便于维护。

依据某种分层战略完善错误处理代码。

整洁的代码读起来令人愉悦。

完善错误处理代码。

整洁的代码只做好一件事。

整洁的代码从不隐藏设计者的意图。

整洁的代码总是看起来像是某位特别在意它的人写的。

没有重复代码。

体现系统中的全部设计理念。

包括尽量少的实体，比如类、方法、函数等。

有意义的命名是体现表达力的一种方式。

消除重复代码，提高表达力，提早构建简单抽象。

不要重复代码，只做一件事，表达力，小规模抽象。

每个例程都让你感到深合己意。

那代码就是深合你意。它明确、简单、有力。

整洁的程序好到你根本不会注意到它。

读与写花费时间的比例超过10:1。

"让营地比你来时更干净。"

艺术书并不保证你读过之后才能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。

若我们受人所制，亲爱的勃鲁托斯，那错也在我们身上，不能怪罪命运。

## 第2章 有意义的命名

名副其实。

如果名称需要注释来补充，那就不算是名副其实。

选择体现本意的名称能让人梗荣立理解和修改代码。

问题不在于代码的简洁度，而是在于代码的模糊度：即上下文在代码中未被明确体现的程度。

只要简单改一下名称，就能轻易知道发生了什么。

以同样的方式拼写出同样的概念才是信息。瓶邪前后不一致就是误导。

如果名称必须相异，那其意思也应该不同才对。

废话是另一种没意义的区分。废话都是冗余。

要区分名称，就要以读者能鉴别之处的方式来区分。

使用读得出来的名称，如果名称读不出来，讨论的时候就会像个傻鸟。

单字母名称仅用于短方法中的本地变量。名称长短应与其作用于大小相对应。

长名称胜于短名称，搜得到的名称胜于用自造代码写就的名称。

把类型或作用于编进名称里面，徒然增加了解码的负担。

应当把类和函数做得足够小，消除对成员前缀的需要。

聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。

类名和对象名应该是名词或名词短语，类名不应当是动词。

方法名应当是动词或动词短语，属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。

重载构造器时，使用描述了参数的静态工厂方法名。可以考虑将相应的构造器设置为private，强制使用这种命名手段。

    Complex.FromRealNumber(23.0) 通常好于 new Complex(23.0)

宁可明确，毋为好玩。言到意到，意到言到。

给每个抽象概念选一个词，并且一以贯之。

    例如，使用fetch、retrieve和get来给多个类中的同种方法命名。

函数名称应当独一无二，而且要保持一致，这样才能不借助多余的浏览就找到正确的方法。

避免将同一单词用于不同目的。遵循"一词一意"。

代码作者应尽力写出易于理解的代码。

使用解决方案领域名称。

使用源自所涉问题领域的名称。

    优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念。

添加有意义的语境。

只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。

    精确是命名的要点。

取好名字最难的地方在于需要良好的描述技巧和共有文化背景。

## 第3章 函数

函数的第一规则是要短小。函数的缩进层级不该多于一层或两层。

函数只做一件事。只做一件事的函数无法再被切分为多个区段。

    编写函数是为了把大一些的概念拆分为另一抽象层上的一系列步骤。
    换言之，函数应该只在紧邻的两个抽象层次上拆解，而不应该跨越多个抽象层次。

每个函数一个抽象层级。

自顶向下阅读代码：向下规则。

Switch语句天生要做N件事，写出短小的switch语句很难。

    switch语句尽量只出现于工厂方法中用于创建多态对象，而且隐藏在某个继承关系中，在系统的其他部分看不到。

长而具有描述性的名称，要比短而令人费解的名称好。

函数参数越少越好。

    参数与函数名处在不同的抽象层级，它要求你了解目前并不特别重要的细节。

单参数函数可能是操作该参数，将其转换再输出；也有可能是将参数视为事件（event），有输入而无输出，此时函数使用该参数修改系统状态。

不要使用标识参数，标识参数丑陋不堪，它是在宣布本函数不止做一件事。

如果函数需要三个或以上的参数，就说明其中一些参数应该封装为类了。

    一组参数被统统传递，往往就是该有自己名称的某个概念的一部分。

给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。

    函数和参数应当形成一种非常良好的动词/名词对形式。

无副作用：函数承诺只做一件事。

    应避免使用输出参数，如果必须要修改某种状态，就修改所属对象的对象。

分隔指令与询问

    函数要么做什么事，要么回答什么事，但二者不可兼得。

使用异常替代返回错误码：错误处理代码就能从主路径中分离出来，得到简化。

抽离Try/Catch代码块，另外形成函数，分离Control和具体Logic。

函数应该只做一件事，错误处理就是一件事，因此，处理错误的函数不该做其他事。

使用异常代替错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。

Don't repeat yourself.

    重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。

> 每个系统都是使用某种领域特定语言搭建，而这种语言是程序员设计来描述那个系统的。
> 
> 函数是语言的动词，类是名词。
> 
> 编程艺术是且一直就是语言设计的艺术。
> 大师级程序员把系统当做故事来讲，而不是当做程序来写。
> 
> 真正的目标在于讲述系统的故事，而你编写的函数必须干净利落地拼装到一起，形成一种精确而清晰的语言，帮助你讲故事。

## 第4章 注释

若编程语言足够有表达力，或者我们擅长用这些语言来表达意图，就不那么需要注释——也许根本不需要。

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

代码在变动，在演化，程序员不能坚持维护注释，注释并不总是随之变动。

不准确的注释要比没注释坏得多。

只有代码能忠实地告诉你它做的事。那是唯一真正准确的信息来源。

注释不能美化糟糕的代码。尽量用代码来阐释意图而不是注释。

唯一真正好的注释是你想办法不去写的注释。

有时，注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式，也会是有用的。

有时，用于警告其他程序员会出现某种后果的注释也是有用的。

注释可以用来放大某种看来不合理之物的重要性。

没有什么比被良好描述的公共API更有用和令人满意的了。

怀注释都是糟糕的代码的支撑或借口，或者对错误决策的修正，基本上等于程序员自说自话。

如果你决定写注释，就要花必要的时间确保写出最好的注释。

程序员的挫败感可以由改进代码结构而消除。

用整理代码的决心来代替创造废话的冲动吧。你会发现自己成为更优秀、更快乐的程序员。

能用函数或变量时就别用注释。

假如你一定要写注释，请确保它描述了离它最近的代码。

别在注释中添加过多或无关的细节描述。

注释及其描述的代码之间的联系应该显而易见。

为只做一件事的短函数选个好名字，通常要比写函数头注释要好。

## 第5章 格式

代码格式很重要。

    代码格式关乎沟通，而沟通是专业开发者的头等大事。

短文件通常比长文件易于理解。

    有可能用大多数为200行，最长500行的单个文件构造出色的系统。

源文件也要像报纸文章那样，名称应当简单且一目了然。

每个空白行都是一条线索，标识出新的独立概念。

空白行隔开了概念，靠近的代码行则暗示了它们之间的紧密关系。紧密相关的代码应该互相靠近。

变量声明应尽可能靠近其使用位置。

相关性越强，彼此之间的距离就该越短。

应该尽力保持代码行短小。

源文件是一种继承结构，其中的信息设计整个文件、文件中每个类、类中的方法、方法中的代码块，也涉及代码块中的代码块。

要让这种范围式继承结构可见，我们依源代码在继承结构中的位置对源代码行做缩进处理。

程序员相当依赖这种缩进模式。

好的软件系统是由一系列读起来不错的代码文件组成的。

## 第6章 对象和数据结构

隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象。

要以最好的方式呈现某个对象包含的数据，需要做严肃的思考。

对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。它们是对立的。

过程式代码（使用数据结构的代码），便于在不改动既有数据结构的前提下添加新函数。

    过程式代码难以添加新数据结构，因为必须修改所有函数。

面向对象代码便于在不改动既有函数的前提下添加新类。

    面向对象代码难以添加新函数，因为必须修改所有类。

> 对于面向对象比较难的事，对于过程式代码却较容易，反之亦然！

模块不应了解它所操作对象的内部情形。

对象隐藏数据，暴露操作，这意味着对象不应通过存取器暴露其内部结构。

方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友说话，不与陌生人谈话。

使用公共访问器把私有变量公开化，会诱导外部函数以过程式程序使用数据结构的方式使用这些变量。

如果ctx是个变量，就应该要求它做点什么，不该要求它给出内部情形。

> 对象暴露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。

    不过貌似Rust的trait可以在不破坏既有继承/接口实现的前提下，无侵入式的为一个已有的类增加一个新的接口实现

> 数据结构暴露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。

我们有时会希望能够灵活地添加新数据类型，所以更喜欢在这部分使用对象。

另外一些时候，我们希望能灵活地添加新行为，这时我们更喜欢使用数据类型和过程。

## 第7章 错误处理

错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。

使用异常而非返回码。

    他们搞乱了调用者代码。调用者必须在调用之后即刻检查错误，而这个步骤很容易被遗忘。

在某种意义上，try代码块就像是事务。catch代码块将程序维持在一种持续状态。

可控异常的代价就是违反开放/闭合原则。

    你得在catch语句和抛出异常处之间的每个方法签名中声明该异常。
    这意味着对软件中较低层级的修改，都将波及较高层级的签名。

可控异常有时也会有用：在那些关键代码库的地方，你必须捕获异常。

你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。

    应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。

当我们在应用程序中定义异常类时，最重要的考虑应该是它们如何被捕获。

将第三方API打包是个良好的实践手段。

    当你打包一个第三方API，你就降低了对它的依赖。
    打包的好处还在于你不必绑死在某个特定厂商的API设计上。

别返回null值。

    返回null值，基本上是在给自己增加工作量，也是在给调用者添乱。
    只要有一处没检查null值，应用程序就会失控。

别传递nul值。

    除非API要求你向它传递null值，否则就要尽可能避免传递null值。
    在大多数编程语言中，没有良好的方法能对付由调用者意外传入的null值。
    恰当的做法就是禁止传入null值。

> 整洁代码是可读的，但也要强固。  
> 可读与强固并不冲突。  
> 如果将错误处理隔离看待，独立于主逻辑之外，就能写出强固而整洁的代码。  
> 单独处理错误，极大地提升了代码的可维护性。  

## 第8章

我们很少控制系统中的全部软件。

在接口提供者和使用者之间，存在与生俱来的张力。

    第三方程序包和框架提供者追求普适性，而使用者则想要集中满足特定需求的接口。
    这种张力会导致系统边界上出现问题。

边界上的接口是隐藏的，它能随来自应用程序其他部分的极小的影响而变动。

我们简易不要将Map（或在边界上的其他接口）在系统中传递。避免从公共API中返回边界接口，或将边界接口作为参数传递给公共API。

我们没有测试第三方代码的职责，但为要使用的第三方代码编写测试，可能最符合我们的利益。

学习第三方代码很难。整合第三方代码也很难。同时做着两件事难上加难。

不要再生产代码中试验新东西，而是编写测试来遍览和理解第三方代码。这叫做学习性测试（leaning tests）。

    我们基本上是在通过核对试验来检测自己对那个API的理解程度。
    测试聚焦于我们想从API得到的东西。

学习性测试毫无成本。
    
    无论如何我们都得学习要使用的API，而编写测试则是获得这些知识的容易而不会影响其他工作的途径。
    学习性测试是一种精确试验，帮助我们增进对API的理解。

当第三方程序包发布了新版本，我们可以运行学习性测试，看看程序包的行为有没有改变。

学习性测试确保第三方程序包按照我们想要的方式工作。

总要有一系列与生产代码中调用方式一致的输出测试来支持整洁的边界。

还有另一种边界，那种将已知和未知分隔开的边界。

    在代码中总有许多地方是我们的知识未及之处，至少目前未知，边界的那边就是未知的。

边界上会发生有趣的事。改动是其中之一。

    有良好的软件设计，无需巨大投入和重写即可进行修改。

边界上的代码需要清晰的分隔和定义了期望的测试。
    
    应该避免我们的代码过多地了解第三方代码中的特定信息。
    依靠你能控制的东西，好过依靠你控制不了的东西。

## 第9章 单元测试

保持测试整洁。

    脏测试等同于没测试——如果不是坏于的话。
    测试是必须随生产代码的演进而修改。

测试代码和生产代码一样重要。它需要被思考、被设计和被照料。

测试带来一切好处。

正是单元测试让你的代码可扩展、可维护、可复用。

测试覆盖率越高，你就越不担心，越有信心。

整洁的测试有三个要素：可读性，可读性和可读性。

    测试可遵循以下模式：构造 - 操作 - 检验。

测试代码应当简单、精悍、足具表达力，但它该和生产代码一样有效。

有些事你大概永远不会在生产环境中做，而在测试环境中做却完全没问题。通常这关乎内存或CPU效率的问题。

单个测试中的断言数量应该最小化。

每个测试函数中只测试一个概念。

整洁的测试还有以下规则：

- Fast: 快速，测试应该够快。
- Independent: 独立，测试应该相互独立。
- Repeatable：可重复，测试应当在任何环境中重复通过。
- Self-Validating：自足验证，测试应该有布尔值输出，无论通过或失败，都不需要通过查看日志文件来确认。
- Timely：及时，测试应及时编写，在生产代码之前编写。

> 或许测试更为重要，因为它保证和增强了生产代码的可扩展性、可维护性和可复用性。
> 如果你坐视测试腐败，那么代码也会跟着腐败。保持测试整洁吧。

## 第10章 类




































